Now that that's out of the way if you're still reading I basically have license to be as cliche as I want. What is this title you may be asking? It's the result of hours and hours of me pondering on a problem I've been having. Defining "Computer Science" in a meaninful way.

Why I Care
---

My stake in this argument comes from an inherent love of computers. I want to dedicate every possible waking minute of my life to the pursute of mastering the practice of their operation and construction. I think this comes from my desire to create. Inside of myself I have a need that I do not fully understand that pushes me to tinker and build. Characterizing it is unneeded because this is inconsiquential to the result: I like building this, computers are really complicated to build so I like building them, computers are tools that let you design and build more things in a realm of a sort of meta-physical plane of existance that only permits data within it's boundries. Data can only permeate into and out of this plane and as a result there are no implicit physical bars preventing the creation of infinitly complex systems that are most certianly more complex then the computers they run on.


Complexity
---

Because there are no physical limits within this Realm of Data our interactions with it must be carfully considered. This stems from an issue brought up by many of the people who have pioneered the field of what we usually refer to as "Computer Science". If this Realm of Data has no constraints when how can we possibly maintain the systems that exist within it? What are our modes of action for containing, identifying, and fixing these complex problems? Every "Computer Scientist" cares about managing these concerns and we do it in many ways. WePhysics limit features exposed to us (DSLs), we hide portions of the problems we are solving that aren't directly related to the issue at hand (Abstractions), we restrict usage of things that have caused up problems in the past and impose conventions for the creation of our data (Coding Standards), we track changes in the systems we own meticulously in an attempt to nail down the source of a problem (VCS), we strictly define the inputs and outputs of data into our Realm of Data as to not plauge it with an infectious disease that will taint it and all of our work so far (Specifications and Invariants), and we do many many many more things that are inumerable all of which I'd love to study and eventually write about.

These are creations of humanity, not of computers. Computers do not care about any of these as they can just, in theory, execute arbitrary commands for arbitrary time over arbitrary datasets. These are all the issues with the human side of the enviroment, not on the machine side.


The Problem
---

This disagreement that exists in our field is not one born out of malice, stupidity, or anything petty of that nature. It is instead a deeply rooted argument in amongst the professionals who work with or practice the conepts of computation. This is a simple fork in the road and neither side has a stake to the claim of the gold in between them. I'd like to attempt to frame this debate as a debate about abstraction. Both sides would like to change the representation of our field because both sides feel as though they are incorrect abstractions for the model at hand.

That's pretty much the only thing I can say about this debate in a fair way. Any other characterization of the opposing, or even my view point, would inherently be tainted by my bias in this argument. So instead of painting an unbiased picture I'll just give you both. How I've conceptualized the issue and how others have conceptualized the issue.


My Side
---

To first understand my opinions we must characterize where my feelings come from. I taught myself to program at 12 with the help of an old British man I met on IRC. I needed help and kept bugging him. With his help he assigned me tasks to carry out, I did them, and from that I grew as a programmer incrementally over the years. This has been a great influance on my life as I've seen what happens to people who go into our computer science education without this background. My cinical, hermit, British friend instilled many values into me that are extremely important and that I feel only "real programmers" will aquire. I define "real programmers" as people who aren't in it for the 9 to 5. People who are interested in programming on personal time and want to be the best programmers they are. A "real programmer" is the subset of a programmer. In my mind that is still acceptable. It's not bad to be a programmer (or since I called the opposite a "real programmer" this nicessitates calling this for of programmer a "fake programmer" in some peoples mind).

Real vs Fake
--

There are master painters and there are people who doodle. Is it fair to say that people who doodle are not valuable? No, it's not. They want to do something littledifferent but that doesn't mean they aren't worth their salt. People who doodle are still needed just as much as people who are master painters. One example of this is that if Pacaso was alive today I don't think I'd be happy if he was the person drawing Dilberts for the paper and similarly I'd not be happy if when I went to the museum to see beutiful art pieces I'd not be happy if when I went there Dilberts were hung and sprawled across every wall (they're funny but I'd just buy a paper, not pay admission to an expensive meuseam).


Being a Programmer
--

So you, or anyone for that matter, wants to be a programmer. How do we go about this? Well first you need to study a bit so you'll probably go download some tooling, write some programs, and now your a programmer. But you aren't "officially" one yet. You've only worked with your code up until this point, you've never worked under people smarter then you who can help you expand your knowladge, and furthermore we all know you don't know everything no matter how long you've studied. How do you improve? Go work with more programmers. First you proceed to do a little open source work but are quickly put off by either politics or people not willing to dedicate as much time as you to projects because they've already learned more then you have. What next? Give up and become a welder!.... I'm kidding (a little bit) but instead you go and get a job as an entry level programmer. Let's go look for this.

I went to indeed (a poorly made website for finding jobs) and typed in two search terms. You will find them and what I recived after my short look.

Software Engineer
--

Sounded cool and you saw some of those open source folks call themselves that! This must be the right place to go! After some reading you see something familiar. You see Google is hiring and say "Hey! I use Google! They're smart I can learn a lot from them" so you click them and read a bit. Sadly you've clicked on a [high level possition)[http://archive.is/SEbbJ#selection-955.0-955.99) that requires a degree. You sit and stair at the screen and see that it requires a Computer Science degree. You've never heard about this but that doesn't sound right. What you do isn't exactly a science you're instantly impressed by all the people who you met in the open source world who call themselves Software Engineers. They must have Science degrees and be Scientists certified by a real life Science Factory (read university). You think for a bit and realize that you should be able to find an internship! In one of those they'll teach you how to be a Software Engineer! After some more searching you are displeased to find that an intern [STILL needs to either have or be following a degree track at a university](http://archive.is/nb5Ac#selection-995.0-995.97) (who the hell want's to work as an intern after they graduate from college you think to yourself?). You continue your search.

Programmer
--

Given your recent experiances with the search engines you decide to be more direct and not get flashy. You search for the thing that describes you best. After more looking you find a job that describes you perfectly! They want someone who programms in their free time, who has a public tract record dating back at least 2 years of experiance, someone who is a good communicator and level headed! You're a perfect fit (GOD DAMMIT HIRE ME!... ok maybe I'm not perfect with the level headed portion of this but you probably are). Then, after reading some coperate message bullshit you find a message mandating you find that they [too want a computer science degree](http://archive.is/Y2C3w#selection-383.0-383.57). You sit back and think some more and confront your open source firends and ask "Hey, I'm trying to improve and find a job doing this because I love it. How do I do that". They all answer back "Get a degree in computer science".

From Self Taught to College
--

You sign up for a university near you. You're working part time to pay for bills and taking out huge loans but this should pay off. Software engineers can make up to 100k/year, did you know?!? Also you know the old montra: you get what you pay for so since you're paying ~15k/semester (1/2 a year) then you must be getting the best of the best! You get into class and the teachers make you buy expensive books. That's no problem for you, you like reading and did it a lot while stuying yourself.

The first few days pass and you find it dificult. Not because of the computer science work but instead you don't enjoy the other classes the college is making you take. You're in Math and Physics which both have very little to do with what you want to do.

The weeks pass and you find yourself stuck. You hate this.

The weeks crawl onward and you find it dificult. Not due to the work, but instead to care. "This won't help me", you think to yourself, "I've been programming for years. I just want to experiment with different recipies, lanuages, and concepts. I'd like to find out how to maintain software. I'd like to find out how to abstract software. I'd like to find out how to build infinitly complex models of reality that aren't complicated by the details of the implementations. That's what would help me the most." But you're stuck. You are surounded by people completely alien to yourself and your mentality.

In this group of people the definition of "Computer Science" seems to be very different. It's certianly not quite like the one you or those job descriptions have been using. Most of these people are old, some of them haven't worked outside of university or journals, many of them haven't worked on open source software, you find most of them don't program in their free time as they are all too happy to walk away from the monitor at the end of their shift and go do "something better with thier time then program". This appauls you and you feel sick to your stomach and you find it dificult to even talk to these people. Sure there are a good odd few here and there who "get it" and how you feel and what you want to do after graduating. Sadly though these people are so different from those you want to work with and yet those people have appointed these people to be the gate keepers of their institutions.

These people are called academics. They care little for computers, abstractions, and software. In fact they consider it beneth them and regard everything you care about as a less important side effect of thier more important work. When you talk to some of them they suggest that you're interpretation of Computer Science is wrong and they are the arbatours of the true definition of Computer Science and suggest that you should just drop out and go to one of those hipster coding camps that you've heard of. When you bring up the fact that most companies specifically ask for a Computer Science degree they say something to the effect of "university isn't for training you for a job, it's for learning".

That's all you wanted in the first place..... but when you hear it like that it isn't what you want at all.

I don't know how this part of the argument continues as I'm still living it. I'll write more as I learn more about this.


Their Side
---

Turing, McCarthy, and others are the founders of our field. They didn't directly call themselves computer scientists but they were. Computer Science isn't the study of Computer it is instead the study of Computation and Computers are an application of Computation in the real world. Most of our work is complicated and you (for some fucking reason) need Calculus, lots of Calculus, to be able to be one of us. It's probably a good idea to study Liner Algebra too. You need to be able to make Proofs so get ready for even more Math classes to teach you about this. You'll also need Physics. Lots of Physics. Why, you ask? Well Physics is the application of Math. It is using Math to solve problems. As such that's all you'll be doing in Computer Science. Also you need to take some classes on Cryptography and Networking. With Cryptography you'll be able to apply some really cool Math like curve fitting, lattice structures, and even be able to question what Complexity is! The Networking is here, not because we actually like it, but instead it's REALLY great to use for writing Graph  traversal Algorithms! Speaking of Algorithms and Complexity, don't worry about it. Just remeber these and you'll be fine: Tree, Set, Matrix, Graph, List, Map. We'll start you off with those, if you're not board to death by the end of it then you're probably ok in our field. Hell you're probably even a Math minor like us! Aren't we all so smart here in our little bubble? Those people outside are just stupid and trying to put a lable on us that doesn't belong here! We are the true Computer Scientists, not those morons who aren't smart enough to make it in our fields.

(Ok... so I definetly don't fit the bill for the level headed part.... and this definatly isn't unbiased)


My Analysis
---

We've some how come to an era in the development of Computer Science as a field where when you attempt to study it you learn about everything BUT computers or programming (I say come to an era but it may have always been like this). The rest of the world sees Computer Scientist as someone who knows everything about computers, problem solving, abstraction, software development and maintnence, and everything that comes along with those topics. Academics (Their Side) don't see it that way. They see it from the perspective of people who are Mathematicians. They want you to know about Math, the Application of Math, the way of Mathimatically Proving, and many other things. Where does this come from?

I think this stems from misguided opinions of what the greats in our field have thought. In SICP they like to say "Computer Science is not about Computers and it isn't a Science" and when they say that people like to hear the first part and ignore the rest of the entire book. They are often misrepresent Sussman's belifes by painting depicting his concerns about the education of students as being entierly on the side of Mathematics and Structure. Having read a bit of SICP I think this is entierly false. He is much more practical in his actions than professors I've dealt with. Sure he want's to talk about the theories of computation but he wants the students to do this in a REAL setting. Not an imaginary one. He recognizes the coupling of his ideas to the practice of them and doesn't attempt to unnaturally seprate them in a futile attempt to talk only about the concepts of computation. His practices are gounded in implementable solutions that translate directly to not only being a good Computer Scientist but also a good Programmer. His book talks about abstraction, theories of computation, and many other things I'd give an arm and a dick to learn about. Sadly though, I'm not an MIT student and I have no guarantee that the other courses at MIT don't fall off the band wagon after you leave the hands of his course.

It is my opinion that a small minority of Computer Science professors have a warped perception of what the reality of Computer Science is. Much like the Data in our Realm of Data we touched upon earlier Academia may very well be it's own Realm. One where much like our academics are stuck much like the data in our programs. Rather then Data I/O in our Realm the Academics have a different issue. They take Students I/O. These students go through a very simple state machine and pass through in either three states:


1. The are stuck in the machine and buy the definition held by the majority of their peers
2. They can't deal with the BS required to finish their degree and they leave without one
3. They can deal with the BS required to finish their degree and they leave with one

None of these people know significantly more then the other two but one mays much more money then the other two, one is much more respected then the other two, and one is skrewed from all the debt they have. These three states and who they are applied to vary from time to time but as it currently stands:

1. The New Academic is Respected
2. The Dropout is Fucked
3. The Graduate is (sometimes) Making 100k/year

And it is this that continues the cycle. The dropouts are far worse off now that they have a 2-4 year gap where they didn't do anything in their resume and likely don't want to say "oh I failed out of college" to a recruiter. The Graduate makes the risk look worth it to young un-suspecting marks. the New Academic brings prestige to the university from the other nodding heads that read their research in their small bubble.

Does this mean Academics don't do anything useful? Does this mean dropouts are allways failures and won't come of anything? Those this mean graduates always make 100k/year? Not. At. All. But that's what the average person who hasn't been through the house of mirros of college sees when they look at it.

What are the Side Effects of This
---

The graduates are usually seen as "experts" after leaving college when they in reality know extremely little about software development. I recently just finished what is largely accepted as the hardest couse in my school (CS288 @ NJIT /w Andrew Sohn, I need to write about how this was stupid one day. Someone please remind me). The most difficult assignemnt I've been asked to do was write a program that impelements Jacobi's Method. This class was a mess but this was the most difficult thing I've ever programmed. Not because it was a hard program but because the entire eco-system of the class was Academics attempting to be Software Engineers. [His code was a mess](https://hastebin.com/qitaxasobu.c) and it was hard to implement because he told us to just implement the algorithm from wikipedia which looks like it was typed up by a [toddler working in a math department who knew nothing about CS notation or programming languages](https://en.wikipedia.org/wiki/Jacobi_method#Algorithm). It has every single problem in the book of Software Engineers. No comments and not self commenting, no explination in laymens terms, no abstractions of the concepts being used, single letter variable names, non-typeable variable names, and a reliance on specific problem-domain knowladge. It's horrible and that's why it was hard. It was artificial difficulty, not real difficulty. And from this, I'd like to talk about why the results of this will be.

Anyone who cannot see this is burrying their heads in the sand. There is a common statistic that says [68% of all IT projects fail](http://www.techrepublic.com/blog/tech-decision-maker/study-68-percent-of-it-projects-fail/). How could this be? When you hire from a pool of students who thinks that is the ideal for software implementation? That's crazy. That's bound to cause problems. No one knew what was going on, we all failed all of the exams (the averages were 60/100, 50/100, and on the final after talking we were on average only able to answer 10/50 questions). We all know that you can't fail everyone so he curved like crazy. I achived a C+ having recived a 55, an 88, and probably no more then a 40 on the final. This method of teaching churns out a low caliber programmer. To be fair: if you wanted to work in Academic Computer Science you'd probably turn out well in my school but if you wanted to do anything in the real world, you'll need to spend the same ammount of time studying your Programming concepts work as you do your Academic Computer Science work.

The Final Solution
---

There is a simple two-step solution that presents itself to me. One that, if implemented, would greatly lower the amount of money wasted, secutiry forfited, and lives lost from bad software products and practices.

1. Stop teaching bad pactices and create a major and field dedicated to software engineering and programming
2. Stop conflaiting Academic Computer Science and Software Engineering Computer Science

Goal one is an academic goal. Goal two is a social goal. I'm not sure which one will be harder to implement.

My Dream Course
---

I can't offer a solution to a social issue, society needs to work that one out, but I can offer a solution to an educational issue. This article sprung out of a comment I made on Hacker News (one of the few places on the internet you can have serious convorsations with people of all walks of life who are almost always far smater then you are; I love learning from the many lessons those people have to teach me). On there I made these statements.

My Orinial Comment
---
I've been rattling this idea around in my head and, although it may sound crazy, I think C is a little high level to start an adult out on. I know many people won't agree with this but all of the people I admire in the world of CS and everyone who is a true scottsman for all intents and purposes loves dipping down to a lower level once and a while. I think the best way to learn about computer science it to program for a machine so simple anyone can understand how every bit works. No magic. One such example of this is old retro computers. Systems like old Z80 machines. If I wanted to teach everyone how to be an amazing programmer I'd start them out on an old broken computer, help them fix it and get it working, help them get programming and wet their feet copying in some hex values to get some binaries programs working, start them up with a notebook and give them "homework" of a few really useful routines to write for themselves in Assembly. They'd write the assembly and compile it with pen and paper so ther really understand what's going on. Then we'd write an assembler together, then from an assembler we'd write up a standard library, then from there we'd get to a compiler for a language they make up. After that the sky is the limit. Maybe help them start writing their own ROMs for the machines and see where they can take it. (Maybe 6 months to 1 year) If someone was able to get through that they'd really, truely, understand everything in the computer. Funnily enough that's what most of my CS education feels like right now (except much less fun and I'm learning less then I would from this). Intersplice these sessions of training with lectures of computer architecture, basics of electronics, how each of the components in the computer works, different protocalls and why they are used. You'd be very well rounded and pretty much well suited for many programming jobs. Follow this up with a slow maybe 5 week transition period where you come back to a modern computer, learn some C and why C was made, learn some LISP was made, and then apply that to real world projects while only introducing new technologies and concepts only when they are of imediate use and then allow the student to learn directly from taking advantage of the benifits of these technologies. I think a student would come out very well rounded from something like this. I wish I could pay for an education like this.

Expansion
---
This is how I feel we can change one of the deep seeded problems with Software Engineers around the world. There is no place on Earth to get a hard-core Software Engineering degree. Since no such one is available, I think employers just flocked to the next best thing. If we make an alternative that is explicitly for Software Engineering then it must, in my opinion, have the following.

1. You understand everything about your hardware from an abstract, and somtimes practical, viewpoint
2. You must write a lot of software
3. You must understand every component of the software stack, how everything links together to form the computational enviroments we make use of today

How do we do This?
---

Well for starters you sure as hell don't tell the students. That's the last thing you do. What you do is tell them to do something that is simple, enjoyable, and that is designed to make them learn what you want them to learn in order to continue. You [head fake](https://www.cs.cmu.edu/~pausch/Randy/pauschlastlecturetranscript.pdf) them. To design a course like this would be extremely "simple". You'd get a bunch of game developers in a room and ask them how to do it. They are the masters of the art of the untold story and as such they are likely to be the masters of untaught education.

Teach the Basics
--

Start as low as you can go and make the students climb the mountain that is all the knowladge of our fields. Build up from nothing into something so the students have very small challegenes at first (how do I add numbers and what are registers) that will quickly evolve into larger problems (what is the stack and why can't I store infinite data) to even harder ones to answer (how do I tell if my program will always finish). In the end they should make something. They should come out having actually done something. Even if it means nothing out of context they should be able to put something on their wall (whether it's a flash drive or a computer running software they've written) and be able to say "what's on there is a complete operating system and all the related services for those, I made all of them from scratch, I wrote assembly by hand, climbed a mouintan to get where I am, and from that experiance I know I can climb any task no matter how daunting".


Lectures != Learning
--

Getting told information is worthless without context or even a desire to know it. Due to this limitation of the human mind we often observe that computer science students are unable to learn about data structures, abstractions, and other principles due the their lack of experiance and pain. Before these are taught they need to feel the pain of a world without them. Don't tell a student about order notation, let them discover that adding nested loops makes things really slow. Nudge them into a way of comparing two functions with different looping constructs and ask them to prove to you why one is slower then the other.

Projects and Many More Interesting Projects
--

Find out what the students want to learn how to build and show them they can build it. Anything, no matter how complex it seems, can be implemented in a reasonable amount of time. Do they want to implement an OS? It won't be amazing but we can do it. A database server that allows complex queries? Won't be too fast but it'll give you the right result. Want to build a game? It won't be AAA but you'll get every concept involved. Education is meant to be a microcosm of the real world where you are allowed and encoraged to experiment with different concepts often barred from your view outside of academia. Without this time of exploration and creativity I'd doubt that many of the famious scientists we know of today would have existed.

Don't Test Their Knowladge, Make Them Prove it.
--

No interviewer is going to start an interview with a test. Pen and paper, time limit, and other things like that. They are going to sit down and talk to a student. A student should be able to explain every portion of a project they worked on in great detail while only talking about relative factors. Software is a commodity, describing your goods is a fundimenal portion of any sales transaction. As such it is a skill that is just as needed as knowing the basic argument syntax to GCC.

Make Them Program Every Day
--

If you are a Software Engineer you should never stop programming. There shouldn't be a week that goes buy without programming. Machinists don't sit on their ass for weeks on end doing nothing. They refine their abilities even in downtime (when they have it) by constantly improving tooling or working on contract work. There should never be idle time in a mill and there should never be idle time in front of a keyboard. Always read and always write (not specifically code but that's preferable).

Nothing is Impossible
--

Any program just boils down into some mov, jmp, cmp, call, add, sub, mul, and div instructions ([and sometimes only MOV](https://github.com/xoreaxeaxeax/movfuscator)). If you want to build something the only thing stoping you from doing it is yourself.


Don't Think of us as a Science, we are a Trade
--

There may be a world for a Computer Science field that is purely about ficticious computations. That world is not the same world I live in or at least the portion of it I live in. We need to be able to solve real world problems. That may involve the usage of theory to abstract complex portions away to make the problem simpler to deal with but I don't think that should be the main focus of a Computer Science degree. Not as the way I see it. 

Do I Have all the Right Answers?
---

Absolutly not but I've not heard any spectacular agruments against these points. Any aguments will get subsiquent responce posts to correctly rebute them or agree with them and expand on why I think they are right.

Spelling corrections will be made but content additions or corrections will not. This is my opinion and even though it will definetly change with time this is ok for now.

Please email me complaints and comments to:

```
domain = "blog.gravypod.com";
first_dot = domain.indexOf(".");
second_dot = domain.indexOf(".", first_dot);
// Take between blog. and .com
user = domain.substr(first_dot + 1, second_dot)
// Take after blog.
server_domain = domain.substr(first_dot + 1)
email = user + "@" + server_domain
```
